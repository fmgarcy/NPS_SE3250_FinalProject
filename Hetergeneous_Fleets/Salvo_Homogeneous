#HOMOGENEOUS 

import numpy as np
import matplotlib.pyplot as plt
#from se3250lib import list_all_ships

LCS = "LCS-Freedom" # @param ["None", "LCS-Freedom", "LCS-Independence"]
LCS_Quantity = "1" # @param ["0", "1", "2", "3", "4"]
DDG = "DDG-Arleigh-Burke" # @param ["None", "DDG-Arleigh-Burke"]
DDG_Quantity = "1" # @param ["0", "1", "2", "3", "4"]
CG = "CG-Ticonderoga" # @param ["None","CG-Ticonderoga"]
CG_Quantity = "1" # @param ["0", "1", "2", "3", "4"]
BluTest = "0" # @param ["0", "1", "2", "3", "4"]
Friendly_Defensive_Weapon_Type = 'RIM-66M' # @param ["RIM-116", "RIM-66M", "RGM-84", "RGM-184A", "Test-1"] {allow-input: true}
Friendly_Offensive_Weapon_Type = 'AGM-84E' # @param ["AGM-114L", "AGM-84E", "BGM-109", "Test-1"] {allow-input: true}

Destroyer = "Destroyer-055D-Renhai" # @param ["None", "Destroyer-055D-Renhai", "Destroyer-052D-Luyang-III"]
Destroyer_Quantity = "1" # @param ["0", "1", "2", "3", "4"]
Frigate = "Frigate-054A-Jiangkai-II" # @param ["None", "Frigate-054A-Jiangkai-II", "Frigate-053H3-Jiangwei-II"]
Frigate_Quantity = "1" # @param ["0", "1", "2", "3", "4"]
Corvette = "Corvette-056A-Jiangdao" # @param ["None", "Corvette-056A-Jiangdao"]
Corvette_Quantity = "1" # @param ["0", "1", "2", "3", "4"]
RedTest = "0" # @param ["0", "1", "2", "3", "4"]
Hostile_Offensive_Weapon_Type = 'YJ-18' # @param ["YJ-18", "YJ-12", "YJ-83", "Test-2"] {allow-input: true}
Hostile_Defensive_Weapon_Type = 'HQ-10' # @param ["FL-300N", "HQ-10", "HQ-16", "Test-2"] {allow-input: true}
Hostile_Scouting = 22 # @param {type:"slider", min:0, max:100, step:1}

#Conversions
LCS_Quantity = int(LCS_Quantity)
DDG_Quantity = int(LCS_Quantity)
CG_Quantity = int(LCS_Quantity)
Destroyer_Quantity = int(LCS_Quantity)
Frigate_Quantity = int(LCS_Quantity)
Corvette_Quantity = int(LCS_Quantity)
BluTest = int(BluTest)
RedTest = int(RedTest)

class Ship:
    ''' A ship carrying anti-ship cruise missiles.

    Attributes:
        * type (str): the type of ship, for labeling purposes only.
        * op (int): the number of anti-ship cruise missiles the ship can fire in one salvo.
        * dp (int): the number of SAM the ship can fire in one salvo against incoming missiles.
        * sp (float): initial staying power in missile hits.
        * hp (float): hit points remaining.
        * status (fraction): fraction of its staying power remaining. 1 is intact, 0 is OOA.
        * age (int): the age of the ship in years.
        * training (float): the crew training level, a value between 0 and 1. ex; 0 - no training, 1 - max level of training
    '''

    def __init__(self, type, classtype, op, dp, sp, age=1, training=0.0):
        self.type = type
        self.classtype = classtype
        self.op = op
        self.dp = dp
        self.sp = sp
        self.hp = sp
        self.status = 1
        self.age = age
        self.training = training

    def damage(self, damage):
        ''' Lowers the ship's 'hp' attribute by the input amount.

        Args:
            * damage (float): points of damage to subtract. HP cannot go below 0.
        '''
        damage = min(damage, self.hp)
        damage = max(damage, 0)
        self.hp -= damage
        self.status = self.hp / self.sp

    def ascm_fire(self):
        ''' Returns cruise missile salvo size based on status.'''
        return self.op * self.status

    def sam_fire(self):
        ''' Returns SAM salvo size based on status.'''
        return self.dp * self.status

    def __str__(self):
        ''' String override. Returns ship type, status as percentage, OP, DP, age, and training.'''
        shipStatus = round(self.status * 100, 2)
        shipOp = round(self.ascm_fire(), 2)
        shipDp = round(self.sam_fire(), 2)
        shipString = "{} ({}%) OP: {} DP: {} Age: {} Training: {}\n".format(self.type, shipStatus, shipOp, shipDp, self.age, self.training)
        return shipString

class Missiles:
    ''' The specification of the missile systems carried by a group of ships.

    Attributes:
        * launch_reliability (fraction): fraction of cruise missiles that launch successfully.
        * ascm_to_hit (fraction): fraction of cruise missiles that hit, in the absence of defences.
        * sam_to_hit (fraction): fraction of SAM that successfully intercept incoming missiles.
    '''
    def __init__(self, type, classtype, launch_reliability=1, ascm_to_hit=1, sam_to_hit=1):
        self.type = type
        self.classtype = classtype
        self.launch_reliability = launch_reliability
        self.ascm_to_hit = ascm_to_hit
        self.sam_to_hit = sam_to_hit

    def offensive_modifier(self):
        ''' Returns the fraction of missiles that launch AND hit.'''
        return self.launch_reliability * self.ascm_to_hit

class Group:
    ''' A group of ships.

    Attributes:
        * side (str): the group's side identifier, for labelling purposes.
        * ship (Ship): the ship type the group is composed of.
        * units (int): the number of ships of type (ship) in the group.
            * oob (list): a list of Ship objects representing the group.
        * scouting (fraction): fraction of enemy group that can be located and targeted.
        * readiness (fraction): efficiency of the group's defences.
        * missiles (Missiles): the missile systems used by the group.
    '''
    def __init__(self, side, ship, classtype, units, scouting=1, readiness=1, offensive_missiles=None, defensive_missiles=None):
        self.side = side
        self.oob = [Ship(ship.type, ship.classtype, ship.op, ship.dp, ship.sp, ship.age, ship.training) for i in range(units)]
        self.classtype = classtype
        self.scouting = scouting
        self.readiness = readiness
        self.offensive_missiles = offensive_missiles or Missiles(classtype)
        self.defensive_missiles = defensive_missiles or Missiles(classtype)

    def striking_power(self):
        salvoSize = sum(ship.ascm_fire() for ship in self.oob)
        strikingPower = salvoSize * self.scouting * self.offensive_missiles.offensive_modifier()
        return strikingPower

    def defensive_power(self):
        defensiveSalvoSize = sum(ship.sam_fire() for ship in self.oob)
        defensivePower = defensiveSalvoSize * self.readiness * self.defensive_missiles.sam_to_hit
        return defensivePower

    def combat_power(self, enemy):
        combat_power = self.striking_power() - enemy.defensive_power()
        return combat_power

    def total_status(self):
        ''' Returns the sum of the 'status' attributes of all ships in the group.'''
        return sum(i.status for i in self.oob)

    def damage(self, damage):
        ''' Damages the group. Applied to all ships consecutively until damage reaches
        zero, or no more targets are available.

        Arguments:
            * damage (float): the total amount damage to inflict upon the group.
        '''
        while damage > 0 and self.total_status() > 0:
            for i in self.oob:
                if i.status > 0:
                    if damage > i.hp:
                        damage -= i.hp
                        i.damage(i.hp)
                    else:
                        i.damage(damage)
                        damage = 0

    def __str__(self):
        ''' String override. Returns the percentage of the original staying power remaining,
        and the (equivalent) number of active ships.
        '''
        percentage = round((self.total_status() / len(self.oob)) * 100, 2)
        activeShips = round(self.total_status(), 2)
        groupString = "{}: {}% ({} active ships)".format(self.side, percentage, activeShips)
        return groupString

def calculate_ship_readiness(ship, scouting):
    ship_age = ship.age
    crew_training = ship.training
    # Assuming higher age and lower crew training reduce readiness
    age_factor = max(0, 1 - ship_age / 40)  # Readiness decreases linearly with age up to 40 years
    training_factor = crew_training
    scouting_factor = scouting  # Scouting value is already in the range [0, 1]

    readiness = age_factor * training_factor * scouting_factor

    return readiness

class Battle:
    ''' A battle between two groups.

    Attributes:
        * blu (Group): the BLUFOR group.
        * red (Group): the REDFOR group.
        * duration (int): the duration of the battle in pulses. If zero (default) the
        battle goes on until one side is wiped out.
    '''
    def __init__(self, blu, red, duration = 0):
        self.blu = blu
        self.red = red
        self.duration = duration
        self.pulse = 0
        # Lists for plotting
        self.bluPlot = [self.blu.total_status()]
        self.redPlot = [self.red.total_status()]
        self.time = [0]

    def add_to_plot(self):
        self.bluPlot.append(self.blu.total_status())
        self.redPlot.append(self.red.total_status())
        self.time.append(self.pulse)

    def stalemate(self):
        ''' Checks whether the battle has reached a stalemate. '''
        stalemate_threshold = 0.1  # Adjust this value as needed
        stalemate = (self.blu.combat_power(self.red) <= stalemate_threshold and
                    self.red.combat_power(self.blu) <= stalemate_threshold)
        return stalemate

    def blu_surprise(self):
        ''' Fires one BLUFOR salvo at REDFOR, without retaliation.'''
        if self.pulse == 0:
            print("\nBattle starts between {} and {}\n".format(self.blu.side, self.red.side))
            #display("sim_output", "\nBattle starts between {} and {}\n".format(self.blu.side, self.red.side), append=True)
            print(self)
        self.pulse += 1
        self.red.damage(self.blu.combat_power(self.red))
        print(self)
        # Add new values to the plotting lists
        self.add_to_plot()

    def red_surprise(self):
        ''' Fires one REDFOR salvo at BLUFOR, without retaliation.'''
        if self.pulse == 0:
            print("\nBattle starts between {} and {}\n".format(self.blu.side, self.red.side))
            print(self)
        self.pulse += 1
        self.blu.damage(self.red.combat_power(self.blu))
        print(self)
        # Add new values to the plotting lists
        self.add_to_plot()

    def salvo(self):
        ''' Both sides fire at each other simultaneously.'''
        if self.pulse == 0:
            print("\nBattle starts between {} and {}\n".format(self.blu.side, self.red.side))
            print(self)
        bluDamageSustained = self.red.combat_power(self.blu)
        redDamageSustained = self.blu.combat_power(self.red)
        self.blu.damage(bluDamageSustained)
        self.red.damage(redDamageSustained)
        self.pulse += 1
        print(self)
        self.add_to_plot()

    def resolve(self):
        ''' The battle is resolved for the specified duration, or until one side is wiped out.'''
        if self.duration == 0:
            while self.blu.total_status() != 0 and self.red.total_status() != 0:
                self.salvo()
                # Add new values to the plotting lists
                self.add_to_plot()
                if self.stalemate():
                    print("\nStalemate! Neither fleet can penetrate enemy missile defence.")
                    #display("sim_output", "\nStalemate! Neither fleet can penetrate enemy missile defence.", append=True)
                    break
        else:
            for _ in range(self.duration):
                self.salvo()
                # Add new values to the plotting lists
                self.add_to_plot()

    def plot(self):
        x = np.array(self.time)
        y = np.array(self.bluPlot)
        z = np.array(self.redPlot)

        width = 0.2

        fig, ax = plt.subplots()
        rects1 = ax.bar(x-0.1, y, width, color='tab:blue', zorder=3)
        rects2 = ax.bar(x+0.1, z, width, color='tab:red', zorder=3)

        ax.set_ylabel('Aggregated status')
        ax.set_xlabel('Pulse')

        ax.set_xticks(x)
        #ax.set_yticks(np.arange(0,max(max(y),max(z))+1,1))

        ax.legend((rects1[0],rects2[0]),(self.blu.side,self.red.side), loc=9)

        ax.grid(which='major', axis='y', linestyle=':', alpha=0.5, zorder=0)
        ax.grid(which='minor', axis='y', linestyle=':', alpha=0.25, zorder=0)

        def autolabel(rects):
            for rect in rects:
                height = rect.get_height()
                ax.text(rect.get_x() + rect.get_width()/2., height,
                        '{}'.format(round(height,2)),
                        ha='center', va='bottom')

        autolabel(rects1)
        autolabel(rects2)

        plt.show()


    def __str__(self):
        ''' String override. Returns the pulse number, and the status of the opposing groups.'''
        battleString = "\nPulse {}:\n{} | {}".format(self.pulse, str(self.blu), str(self.red))
        return(battleString)

def calculate_ship_readiness(ship, scouting):
    ship_age = ship.age
    crew_training = ship.training
    # TODO_FJ look into why the following print only prints for the first ship class?
   # print(f"Ship: {ship.type}, Age: {ship_age}, Training: {crew_training}")
    # Assuming higher age and lower crew training reduce readiness
    age_factor = max(0, 1 - ship_age / 40)  # Readiness decreases linearly with age up to 40 years
    training_factor = crew_training

    readiness = age_factor * training_factor * scouting

    return readiness

def get_rand_ship(ship_class):
    matching_ships = [ship for ship, data in ship_inv.items() if data["classtype"] == ship_class]
    if matching_ships:
        return random.choice(matching_ships)
    else:
        return None

def get_rand_weapon(weapon_class):
    matching_weapons = [weapon for weapon, data in wpn_inv.items() if data["classtype"] == weapon_class]
    if matching_weapons:
        return random.choice(matching_weapons)
    else:
        return None

def generate_blufor(lcs_type, lcs_qty, ddg_type, ddg_qty, cg_type, cg_qty, bluetest_qty, offensive_wpn, defensive_wpn, scouting):
    blufor = []
    offensive_missile_types = []
    defensive_missile_types = []

    ships = []
    ship_types = []
    quantities = []

    if lcs_type != "None":
        ship_types.append(lcs_type)
        quantities.append(lcs_qty)

    if ddg_type != "None":
        ship_types.append(ddg_type)
        quantities.append(ddg_qty)

    if cg_type != "None":
        ship_types.append(cg_type)
        quantities.append(cg_qty)

    if bluetest_qty > 0:
        ship_types.extend(["Test-1"] * bluetest_qty)
        quantities.append(bluetest_qty)

    for ship_type, qty in zip(ship_types, quantities):
        if qty > 0:
            ship_data = ship_inv[ship_type]
            ships.extend([Ship(ship_data['type'], ship_data['classtype'], ship_data['op'], ship_data['dp'], ship_data['sp'], ship_data.get('age', 1), ship_data.get('training', 0.0)) for _ in range(qty)])

    offensive_wpn_data = wpn_inv.get(offensive_wpn, {})
    defensive_wpn_data = wpn_inv.get(defensive_wpn, {})
    offensive_wpn = Missiles(offensive_wpn, **{k: v for k, v in offensive_wpn_data.items() if k != 'type'})
    defensive_wpn = Missiles(defensive_wpn, **{k: v for k, v in defensive_wpn_data.items() if k != 'type'})

    blufor_group = Group("USN", ships[0], ships[0].classtype, len(ships), scouting=scouting, offensive_missiles=offensive_wpn, defensive_missiles=defensive_wpn)
    for ship in blufor_group.oob:
        ship.readiness = calculate_ship_readiness(ship, scouting)
    blufor_group.readiness = sum(ship.readiness for ship in blufor_group.oob) / len(blufor_group.oob)
    blufor.append(blufor_group)
    offensive_missile_types.extend([offensive_wpn.type] * len(ships))
    defensive_missile_types.extend([defensive_wpn.type] * len(ships))

    #TODO_FJ - PRINT IS FOR DEBUG PURPOSES ONLY
    print("BLUFOR FLEET: \n")
    for ship in ships:
      print(ship)
    print("Readiness: (Average)\n", blufor_group.readiness)
    print("\nWeapon Inventory: (All ships)")
    print("\n Offense ", offensive_missile_types[0], "\n Defense: ", defensive_missile_types[0])
    print("\n")
    return blufor, offensive_missile_types, defensive_missile_types

def generate_redfor(dest_type, dest_qty, frig_type, frig_qty, corv_type, corv_qty, redtest_qty, hostile_offensive_wpn, hostile_defensive_wpn, scouting):
    redfor = []
    hostile_offensive_missile_types = []
    hostile_defensive_missile_types = []

    hostile_ships = []
    hostile_ship_types = []
    hostile_quantities = []

    if dest_type != "None":
        hostile_ship_types.append(dest_type)
        hostile_quantities.append(dest_qty)

    if frig_type != "None":
        hostile_ship_types.append(frig_type)
        hostile_quantities.append(frig_qty)

    if corv_type != "None":
        hostile_ship_types.append(corv_type)
        hostile_quantities.append(corv_qty)

    if redtest_qty > 0:
        hostile_ship_types.extend(["Test-1"] * redtest_qty)
        hostile_quantities.append(redtest_qty)

    for hostile_ship_type, hostile_qty in zip(hostile_ship_types, hostile_quantities):
        if hostile_qty > 0:
            hostile_ship_data = ship_inv[hostile_ship_type]
            hostile_ships.extend([Ship(hostile_ship_data['type'], hostile_ship_data['classtype'], hostile_ship_data['op'], hostile_ship_data['dp'], hostile_ship_data['sp'], hostile_ship_data.get('age', 1), hostile_ship_data.get('training', 0.0)) for _ in range(hostile_qty)])

    hostile_offensive_wpn_data = wpn_inv.get(hostile_offensive_wpn, {})
    hostile_defensive_wpn_data = wpn_inv.get(hostile_defensive_wpn, {})
    hostile_offensive_wpn = Missiles(hostile_offensive_wpn, **{k: v for k, v in hostile_offensive_wpn_data.items() if k != 'type'})
    hostile_defensive_wpn = Missiles(hostile_defensive_wpn, **{k: v for k, v in hostile_defensive_wpn_data.items() if k != 'type'})

    redfor_group = Group("PLAN", hostile_ships[0], hostile_ships[0].classtype, len(hostile_ships), scouting=scouting, offensive_missiles=hostile_offensive_wpn, defensive_missiles=hostile_defensive_wpn)
    for ship in redfor_group.oob:
        ship.readiness = calculate_ship_readiness(ship, scouting)
    redfor_group.readiness = sum(ship.readiness for ship in redfor_group.oob) / len(redfor_group.oob)
    redfor.append(redfor_group)
    hostile_offensive_missile_types.extend([hostile_offensive_wpn.type] * len(hostile_ships))
    hostile_defensive_missile_types.extend([hostile_defensive_wpn.type] * len(hostile_ships))

    #TODO_FJ - PRINT IS FOR DEBUG PURPOSES ONLY
    print("REDFOR FLEET: \n")
    for hostile_ship in hostile_ships:
      print(hostile_ship)
    print("Readiness: (Average)\n", redfor_group.readiness)
    print("\nWeapon Inventory: (All ships)")
    print("\n Offense ", hostile_offensive_missile_types[0], "\n Defense: ", hostile_defensive_missile_types[0])
    print("\n")
    return redfor, hostile_offensive_missile_types, hostile_defensive_missile_types

# Monte Carlo Simulation
num_simulations = 8  # Specify the desired number of simulations

# Lists to store simulation results
total_cost = []
total_attrition = []
squadron_outcome_probs = []
weapon_outcome_probs = []
attrition_cost_ratio = []
friendly_wins = 0
blu_win_costs = []

for run in range(num_simulations):
    # Generate random friendly fleet configuration with a random varied readiness level
    blufor_readiness = random.uniform(0.0, 1.0) # Generate a random readiness value between 0 and 100%
    blufor, offensive_missile_types, defensive_missile_types = generate_blufor(LCS, LCS_Quantity, DDG, DDG_Quantity, CG, CG_Quantity, BluTest, Friendly_Offensive_Weapon_Type, Friendly_Defensive_Weapon_Type, blufor_readiness)

    # Generate random hostile fleet configuration
    redfor_readiness = Hostile_Scouting/100
    redfor, hostile_offensive_missile_types, hostile_defensive_missile_types = generate_redfor(Destroyer, Destroyer_Quantity, Frigate, Frigate_Quantity, Corvette, Corvette_Quantity, RedTest, Hostile_Offensive_Weapon_Type, Hostile_Defensive_Weapon_Type, redfor_readiness)

    # Create a single battle instance with the random friendly fleet and the random hostile fleet
    if blufor and redfor:
        battle = Battle(blufor[0], redfor[0])
        battle.blu_surprise()

        # Resolve and plot the battle
        battle.resolve()
        battle.plot()

        if battle.blu.total_status() > 0 and battle.red.total_status() == 0:
            friendly_wins += 1

    # Calculate BLUFOR costs
    run_ship_cost = 0
    run_weap_cost = 0


    for blufor_group in blufor:
        num_friendly_ships_lost = sum(1 for ship in blufor_group.oob if ship.status == 0)
        num_friendly_ships_damaged = sum(1 for ship in blufor_group.oob if (0 < ship.status < 1))
        ship_type = blufor_group.oob[0].type  # Get the friendly ship type
        ship_cost = calculate_ship_cost(ship_type, num_friendly_ships_lost, num_friendly_ships_damaged)
        wpn_offensive = offensive_missile_types[0]  # Use the offensive weapon type
        weap_cost = calculate_weap_cost(wpn_offensive, len(blufor_group.oob))
        run_ship_cost += ship_cost
        run_weap_cost += weap_cost
        total_current =run_ship_cost+run_weap_cost

        if battle.blu.total_status() > 0 and battle.red.total_status() == 0:
          blu_win_costs.append(total_current)
          #print("\nBLU WIN: ", blu_win_cost)

        print("\n Run #", run+1, ": \n", "Ship Cost: ",run_ship_cost, "\n Weap Cost: ", run_weap_cost, "\n Run Cost: ", run_ship_cost+run_weap_cost)

    run_cost = run_ship_cost + run_weap_cost
    total_cost.append(run_cost)
    print("\n Total Cost: ", total_cost, "\n")

    # Calculate attrition
    run_attrition = sum(1 for blufor_group in blufor for ship in blufor_group.oob if ship.status == 0)
    total_attrition.append(run_attrition)

    # Calculate probability of friendly positive outcome per squadron size
    squadron_size = sum((LCS_Quantity + DDG_Quantity + CG_Quantity + BluTest_Quantity) for blufor_group in blufor)
    squadron_outcome_probs.append((squadron_size, friendly_wins))

    # Calculate probability of friendly positive outcome per weapon type
    weapon_outcome_probs.append((Friendly_Offensive_Weapon_Type, friendly_wins))
"""
# Confidence Intervals
H0 = "BLUFOR wins mean cost is under budget."
HA = "BLUFOR wins mean cost indicate battle may go over budget."
mean_blu_win_cost = np.mean(blu_win_costs)
std_blu_win_cost = np.std(blu_win_costs)
alpha = 0.05
confidence_level = 0.95  # 95% confidence level
conf_int = norm.interval(confidence_level, loc=mean_blu_win_cost, scale=std_blu_win_cost / np.sqrt(len(blu_win_costs)))

print(f"Mean cost of BLUFOR wins: {mean_blu_win_cost:.2f}\n")
print(f"{confidence_level*100}% confidence interval: {conf_int}\n")

# Hypothesis testing
null_mean_cost = 1000000  # Null hypothesis mean cost
alternative = 'larger'  # Alternative hypothesis: mean cost > 1000000

# Perform the z-test
z_statistic, p_value = sm.stats.ztest(blu_win_costs, value=null_mean_cost, alternative=alternative)

if p_value < alpha:
    print(f"\033[91mReject null hypothesis:\n {HA}\033[0m\n (p-value = {p_value:.5f})")
else:
    print(f"Fail to reject null hypothesis:\n {H0} (p-value = {p_value:.5f})")
"""

# Cost to Attrition Ratio Display
for i in range(len(total_attrition)):
  if total_attrition[i] > 0:
    attrition_cost_ratio.append(total_cost[i] / total_attrition[i])

plt.figure()
plt.hist([attrition_cost_ratio], bins=20, edgecolor='black')
plt.title('Attrition to Cost Ratio')
plt.xlabel('Ratio')
plt.ylabel('Frequency')
plt.show()

# Calculate and display probabilities of friendly positive outcome per squadron size
squadron_outcome_probs_dict = {}
for squadron_size, outcome in squadron_outcome_probs:
    if squadron_size in squadron_outcome_probs_dict:
        squadron_outcome_probs_dict[squadron_size].append(outcome)
    else:
        squadron_outcome_probs_dict[squadron_size] = [outcome]

print("Probabilities of friendly positive outcome per squadron size:")
for squadron_size, outcomes in squadron_outcome_probs_dict.items():
    probability = sum(outcomes) / len(outcomes)
    print(f"Squadron size {squadron_size}: {probability:.2f}")

# Calculate and display probabilities of friendly positive outcome per weapon type
weapon_outcome_probs_dict = {}
for weapon_type, outcome in weapon_outcome_probs:
    if weapon_type in weapon_outcome_probs_dict:
        weapon_outcome_probs_dict[weapon_type].append(outcome)
    else:
        weapon_outcome_probs_dict[weapon_type] = [outcome]

print("\nProbabilities of friendly positive outcome per weapon type:")
for weapon_type, outcomes in weapon_outcome_probs_dict.items():
    probability = sum(outcomes) / len(outcomes)
    print(f"Weapon type {weapon_type}: {probability:.2f}")
